"use strict";(self.webpackChunklh_site=self.webpackChunklh_site||[]).push([[6309],{5269:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>a});var t=n(4848),i=n(8453);const c={sidebar_label:"Tasks"},d="TaskDef and TaskRun",r={id:"concepts/tasks",title:"TaskDef and TaskRun",description:"The execution of work is fundamental to any Workflow engine. A unit of work executed by a computer in LittleHorse is represented by the dual objects TaskDef and TaskRun.",source:"@site/docs/04-concepts/03-tasks.md",sourceDirName:"04-concepts",slug:"/concepts/tasks",permalink:"/docs/concepts/tasks",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_label:"Tasks"},sidebar:"tutorialSidebar",previous:{title:"Nodes",permalink:"/docs/concepts/nodes"},next:{title:"External Events",permalink:"/docs/concepts/external-events"}},o={},a=[{value:"In the API",id:"in-the-api",level:2},{value:"<code>TaskRun</code> LifeCycle",id:"taskrun-lifecycle",level:2},{value:"<code>TaskRun</code> Status",id:"taskrun-status",level:3},{value:"Retries and <code>TaskAttempt</code>",id:"retries-and-taskattempt",level:3},{value:"Interruptibility",id:"interruptibility",level:3}];function l(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(s.h1,{id:"taskdef-and-taskrun",children:[(0,t.jsx)(s.code,{children:"TaskDef"})," and ",(0,t.jsx)(s.code,{children:"TaskRun"})]}),"\n",(0,t.jsxs)(s.p,{children:["The execution of work is fundamental to any Workflow engine. A unit of work executed by a computer in LittleHorse is represented by the dual objects ",(0,t.jsx)(s.code,{children:"TaskDef"})," and ",(0,t.jsx)(s.code,{children:"TaskRun"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["A ",(0,t.jsx)(s.code,{children:"TaskDef"})," is a LittleHorse API Object which defines a certain type of task that can be executed by a computer. A ",(0,t.jsx)(s.code,{children:"TaskRun"})," is a LittleHorse API Object representing an instance of such a task being executed by a computer as part of a ",(0,t.jsx)(s.code,{children:"WfRun"}),"."]}),"\n",(0,t.jsx)(s.h2,{id:"in-the-api",children:"In the API"}),"\n",(0,t.jsxs)(s.p,{children:["A ",(0,t.jsx)(s.code,{children:"TaskDef"}),"'s ID in the API is simply its ",(0,t.jsx)(s.code,{children:"name"}),". Only one ",(0,t.jsx)(s.code,{children:"TaskDef"})," of a given name can exist at any time."]}),"\n",(0,t.jsxs)(s.p,{children:["a ",(0,t.jsx)(s.code,{children:"TaskRun"}),"'s ID in the API is a composite ID, consisting of:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["The ID of its ",(0,t.jsx)(s.code,{children:"WfRun"})]}),"\n",(0,t.jsx)(s.li,{children:"A guid."}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["A ",(0,t.jsx)(s.code,{children:"WfSpec"})," might have a ",(0,t.jsx)(s.code,{children:"Node"})," of type ",(0,t.jsx)(s.code,{children:"TASK"}),". Such a ",(0,t.jsx)(s.code,{children:"Node"})," will have a ",(0,t.jsx)(s.code,{children:"taskDefName"})," field on it which points to a ",(0,t.jsx)(s.code,{children:"TaskDef"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["When a ",(0,t.jsx)(s.code,{children:"WfRun"})," reaches a ",(0,t.jsx)(s.code,{children:"TASK"})," ",(0,t.jsx)(s.code,{children:"Node"}),", a ",(0,t.jsx)(s.code,{children:"TaskRun"})," is created. The associatd ",(0,t.jsx)(s.code,{children:"NodeRun"})," will have a ",(0,t.jsx)(s.code,{children:"task"})," field, containing the ID of the associated ",(0,t.jsx)(s.code,{children:"TaskRun"}),". The status of the ",(0,t.jsx)(s.code,{children:"NodeRun"})," will mirror the status of the associated ",(0,t.jsx)(s.code,{children:"TaskRun"}),"."]}),"\n",(0,t.jsxs)(s.h2,{id:"taskrun-lifecycle",children:[(0,t.jsx)(s.code,{children:"TaskRun"})," LifeCycle"]}),"\n",(0,t.jsxs)(s.p,{children:["When a ",(0,t.jsx)(s.code,{children:"TaskRun"})," is created, the LH Server first assigns the ",(0,t.jsx)(s.code,{children:"input_variables"})," for that ",(0,t.jsx)(s.code,{children:"TaskRun"}),". The ",(0,t.jsx)(s.code,{children:"input_variables"})," of the ",(0,t.jsx)(s.code,{children:"TaskRun"})," must match up in terms of name and type with the ",(0,t.jsx)(s.code,{children:"input_vars"})," of the associated ",(0,t.jsx)(s.code,{children:"TaskDef"}),". This mirrors how the arguments to a function invocation in programming must match the method signature."]}),"\n",(0,t.jsxs)(s.p,{children:["For a ",(0,t.jsx)(s.code,{children:"TASK"})," ",(0,t.jsx)(s.code,{children:"NodeRun"}),", the output of the ",(0,t.jsx)(s.code,{children:"NodeRun"})," (for use with ",(0,t.jsx)(s.code,{children:"Variable"})," mutations) is determined by the output of the first successful ",(0,t.jsx)(s.code,{children:"TaskAttempt"}),"."]}),"\n",(0,t.jsxs)(s.h3,{id:"taskrun-status",children:[(0,t.jsx)(s.code,{children:"TaskRun"})," Status"]}),"\n",(0,t.jsxs)(s.p,{children:["A ",(0,t.jsx)(s.code,{children:"TaskRun"})," can be in any of the following statuses:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"TASK_SCHEDULED"}),": It has been scheduled but a Task Worker has not yet"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"TASK_RUNNING"}),": A Task Worker has received the Task but not yet reported the result."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"TASK_SUCCESS"}),": The ",(0,t.jsx)(s.code,{children:"TaskRun"})," was completed ","\ud83d\ude42"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"TASK_FAILED"}),": An unexpected error or exception was encountered."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"TASK_TIMEOUT"}),": The Task Worker did not report a result for the ",(0,t.jsx)(s.code,{children:"TaskRun"})," within the allotted timeout."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"TASK_OUTPUT_SERIALIZING_ERROR"}),": The Task Worker executed the ",(0,t.jsx)(s.code,{children:"TaskRun"})," but was unable to serialize the result when reporting back to the LH Server."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"TASK_INPUT_VAR_SUB_ERROR"}),": The LH Server was unable to calculate the input variables for the ",(0,t.jsx)(s.code,{children:"TaskRun"}),", or the Task Worker was unable to deserialize them and call the actual function."]}),"\n"]}),"\n",(0,t.jsxs)(s.h3,{id:"retries-and-taskattempt",children:["Retries and ",(0,t.jsx)(s.code,{children:"TaskAttempt"})]}),"\n",(0,t.jsxs)(s.p,{children:["A ",(0,t.jsx)(s.code,{children:"TaskRun"})," has a ",(0,t.jsx)(s.code,{children:"max_attempts"})," field which is used to determine the number of retries for a ",(0,t.jsx)(s.code,{children:"TaskRun"}),". This is determined by the ",(0,t.jsx)(s.code,{children:"TaskNode"})," structure."]}),"\n",(0,t.jsx)(s.admonition,{type:"note",children:(0,t.jsxs)(s.p,{children:["Multiple different ",(0,t.jsx)(s.code,{children:"Node"}),"s and even different ",(0,t.jsx)(s.code,{children:"WfSpec"}),"s can use the same ",(0,t.jsx)(s.code,{children:"TaskDef"}),". Since retries are configured at the ",(0,t.jsx)(s.code,{children:"TaskNode"})," level, it is possible for two ",(0,t.jsx)(s.code,{children:"TaskRun"}),"s of the same ",(0,t.jsx)(s.code,{children:"TaskDef"})," to have a different maximum number of retries."]})}),"\n",(0,t.jsxs)(s.p,{children:["When a ",(0,t.jsx)(s.code,{children:"TaskRun"})," is first created, a ",(0,t.jsx)(s.code,{children:"TaskAttempt"})," is also created. If the ",(0,t.jsx)(s.code,{children:"TaskAttempt"})," comes back with a ",(0,t.jsx)(s.code,{children:"TASK_SUCCESS"})," status, then great! The ",(0,t.jsx)(s.code,{children:"TaskRun"})," is completed, and if it is associated with a ",(0,t.jsx)(s.code,{children:"TASK"})," ",(0,t.jsx)(s.code,{children:"NodeRun"}),", then the output of the ",(0,t.jsx)(s.code,{children:"NodeRun"})," is just the output of the ",(0,t.jsx)(s.code,{children:"TaskAttempt"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["A ",(0,t.jsx)(s.code,{children:"TaskAttempt"})," is considered retryable if it ends with the following states:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"TASK_FAILED"}),", denoting an exception."]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"TASK_TIMEOUT"}),", denoting that the Task Worker did not report the result of the ",(0,t.jsx)(s.code,{children:"TaskAttempt"})," in time."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["If a ",(0,t.jsx)(s.code,{children:"TaskAttempt"})," is retryable and there are sufficient retries left, then another ",(0,t.jsx)(s.code,{children:"TaskAttempt"})," ",(0,t.jsxs)(s.em,{children:["within the same ",(0,t.jsx)(s.code,{children:"TaskRun"})]})," is created. If any of the retry ",(0,t.jsx)(s.code,{children:"TaskAttempt"}),"s succeed, then the output of the ",(0,t.jsx)(s.code,{children:"TASK"})," ",(0,t.jsx)(s.code,{children:"NodeRun"})," is the output of the first successful ",(0,t.jsx)(s.code,{children:"TaskAttempt"}),". If all fail, then ",(0,t.jsx)(s.code,{children:"NodeRun"})," fails."]}),"\n",(0,t.jsx)(s.h3,{id:"interruptibility",children:"Interruptibility"}),"\n",(0,t.jsxs)(s.p,{children:["A ",(0,t.jsx)(s.code,{children:"TaskRun"})," is considered interruptible if its current ",(0,t.jsx)(s.code,{children:"TaskAttempt"})," is interruptible. A ",(0,t.jsx)(s.code,{children:"TaskAttempt"})," is interruptible if it is in any of the following statuses:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"TASK_SUCCESS"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"TASK_FAILED"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"TASK_TIMEOUT"})}),"\n",(0,t.jsx)(s.li,{children:(0,t.jsx)(s.code,{children:"TASK_OUTPUT_SERIALIZING_ERROR"})}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"TASK_INPUT_VAR_SUB_ERROR"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["A ",(0,t.jsx)(s.code,{children:"TaskAttempt"})," in the ",(0,t.jsx)(s.code,{children:"TASK_SCHEDULED"})," or ",(0,t.jsx)(s.code,{children:"TASK_RUNNING"})," state is not considered interruptible; the associated ",(0,t.jsx)(s.code,{children:"ThreadRun"})," will remain in the ",(0,t.jsx)(s.code,{children:"HALTING"})," state until the ",(0,t.jsx)(s.code,{children:"TaskAttempt"})," is reported (either success or failure) or is timed out."]}),"\n",(0,t.jsxs)(s.p,{children:["For more information, see the ",(0,t.jsxs)(s.a,{href:"/docs/concepts/workflows#threading-model",children:[(0,t.jsx)(s.code,{children:"ThreadRun"})," Lifecycle documentation"]}),"."]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>d,x:()=>r});var t=n(6540);const i={},c=t.createContext(i);function d(e){const s=t.useContext(c);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),t.createElement(c.Provider,{value:s},e.children)}}}]);