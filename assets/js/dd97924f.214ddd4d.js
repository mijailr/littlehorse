"use strict";(self.webpackChunklh_site=self.webpackChunklh_site||[]).push([[832],{635:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>p,frontMatter:()=>a,metadata:()=>c,toc:()=>d});var r=n(4848),s=n(8453),o=n(1470),i=n(9365);const a={},l="Background",c={id:"developer-guide/grpc/basics",title:"Background",description:"The public LittleHorse API is a GRPC service exposed by the LH Server. We have complete auto-generated documentation for our GRPC Service and Protocol Buffers on our docs site. For the highly curious readers, you can find the actual protocol buffer code that underpins our system in our source code repository.",source:"@site/docs/05-developer-guide/09-grpc/00-basics.md",sourceDirName:"05-developer-guide/09-grpc",slug:"/developer-guide/grpc/basics",permalink:"/docs/developer-guide/grpc/basics",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:0,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Using the LittleHorse API",permalink:"/docs/developer-guide/grpc/"},next:{title:"Managing Metadata",permalink:"/docs/developer-guide/grpc/managing-metadata"}},u={},d=[{value:"LittleHorse GRPC Quickstart",id:"littlehorse-grpc-quickstart",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Read-Only Requests and Mutating Requests",id:"read-only-requests-and-mutating-requests",level:2},{value:"List and Search",id:"list-and-search",level:2},{value:"What is an LH API Object?",id:"what-is-an-lh-api-object",level:3},{value:"Pagination",id:"pagination",level:3}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"background",children:"Background"}),"\n",(0,r.jsxs)(t.p,{children:["The public LittleHorse API is a GRPC service exposed by the LH Server. We have complete ",(0,r.jsx)(t.a,{href:"/docs/api",children:"auto-generated documentation"})," for our GRPC Service and Protocol Buffers on our docs site. For the highly curious readers, you can find the actual protocol buffer code that underpins our system in our ",(0,r.jsx)(t.a,{href:"https://github.com/littlehorse-enterprises/littlehorse/schemas/service.proto",children:"source code repository"}),"."]}),"\n",(0,r.jsx)(t.admonition,{type:"tip",children:(0,r.jsxs)(t.p,{children:["For background, we would recommend checking out the GRPC documentation for a primer on GRPC in ",(0,r.jsx)(t.a,{href:"https://grpc.io/docs/languages/java/",children:"Java"}),", ",(0,r.jsx)(t.a,{href:"https://grpc.io/docs/languages/go/",children:"Go"}),", and ",(0,r.jsx)(t.a,{href:"https://grpc.io/docs/languages/python/",children:"Python"}),"."]})}),"\n",(0,r.jsxs)(t.p,{children:["Because the public LittleHorse API is a GRPC service, you may notice that the ",(0,r.jsx)(t.code,{children:"LHConfig"})," object in all three of our SDK's has a ",(0,r.jsx)(t.code,{children:"getStub()"})," method or equivalent. This returns the autogenerated GRPC client in the appropriate language."]}),"\n",(0,r.jsx)(t.p,{children:"This page describes several patterns in the LittleHorse API. Some of these patterns come directly from GRPC (such as error handling and status codes), and others such as our implementation of cursor-based pagination are specific to LittleHorse."}),"\n",(0,r.jsx)(t.h2,{id:"littlehorse-grpc-quickstart",children:"LittleHorse GRPC Quickstart"}),"\n",(0,r.jsxs)(t.p,{children:["The entities in our GRPC service are protocol buffers. You can find our up-to-date API contract in our ",(0,r.jsx)(t.a,{href:"/docs/api",children:"api documentation"}),". Our SDK's in Java, Go, and Python ship with\npre-compiled protobufs for LittleHorse: you don't need to add an extra dependency or compile the protobuf yourself."]}),"\n",(0,r.jsxs)(t.p,{children:["The below is an example of how to access a GRPC client, build a protobuf, and make a request in Java, Go, and Python. The request we will make is the ",(0,r.jsx)(t.a,{href:"/docs/api#putexternaleventdef",children:(0,r.jsx)(t.code,{children:"rpc PutExternalEventDef"})}),"."]}),"\n",(0,r.jsxs)(o.A,{children:[(0,r.jsx)(i.A,{value:"java",label:"Java",default:!0,children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'package io.littlehorse.quickstart;\n\nimport java.io.IOException;\nimport io.littlehorse.sdk.common.LHLibUtil;\nimport io.littlehorse.sdk.common.config.LHConfig;\nimport io.littlehorse.sdk.common.proto.LittleHorseGrpc.LittleHorseBlockingStub;\n\n// All protobuf objects can be found in this package.\nimport io.littlehorse.sdk.common.proto.ExternalEventDef;\nimport io.littlehorse.sdk.common.proto.PutExternalEventDefRequest;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        // First, create an LHConfig. Using the default constructor loads the\n        // configurations from your environment variables.\n        LHConfig config = new LHConfig();\n\n        // Get a GRPC client. Java GRPC has two types: "Blocking" and regular.\n        // "Blocking" stubs are easier to work with as they are synchronous.\n        LittleHorseBlockingStub client = config.getBlockingStub();\n\n        // Build the request\n        PutExternalEventDefRequest req = PutExternalEventDefRequest.newBuilder()\n                .setName("my-external-event")\n                .build();\n\n        // Make the request\n        ExternalEventDef result = client.putExternalEventDef(req);\n\n        // Print the result in JSON format\n        System.out.println(LHLibUtil.protoToJson(result));\n    }\n}\n'})})}),(0,r.jsx)(i.A,{value:"go",label:"Go",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'package main\n\nimport (\n\t"context"\n\t"log"\n\n\t// Common utilities are found in this package\n\t"github.com/littlehorse-enterprises/littlehorse/sdk-go/common"\n\n\t// All protobuf data models and grpc clients are found in this package\n\t"github.com/littlehorse-enterprises/littlehorse/sdk-go/common/model"\n)\n\nfunc main() {\n\t// Create a config using the environment variables.\n\tconfig := common.NewConfigFromEnv()\n\n\t// Load the client\n\tclient, err := config.GetGrpcClient()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Create the request protobuf structure\n\treq := &model.PutExternalEventDefRequest{\n\t\tName: "my-external-event-def",\n\t}\n\n\t// Make the request\n\tvar result *model.ExternalEventDef\n\tresult, err = (*client).PutExternalEventDef(context.Background(), req)\n\n\tcommon.PrintProto(result)\n}\n'})})}),(0,r.jsx)(i.A,{value:"python",label:"Python",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'from littlehorse.config import LHConfig\n\n# All protobuf models are in this package\nfrom littlehorse.model import LittleHorseStub, PutExternalEventDefRequest, ExternalEventDef\n\n# You can use this utility to print protobuf prettily (:\nfrom google.protobuf.json_format import MessageToJson\n\n\nif __name__ == \'__main__\':\n    # Create a config object using the environment variables.\n    config: LHConfig = LHConfig()\n\n    # Create the GRPC Client (in grpc, a client is called a "stub")\n    client: LittleHorseStub = config.stub()\n\n    # Formulate the request, which is a protobuf object.\n    request = PutExternalEventDefRequest(name="my-external-event-def")\n\n    # Make the request!\n    result: ExternalEventDef = client.PutExternalEventDef(request)\n\n    # Print it out\n    print(MessageToJson(result))\n'})})})]}),"\n",(0,r.jsx)(t.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsxs)(t.p,{children:["The LittleHorse API uses the standard GRPC Error Codes, and we strictly follow the conventions described in ",(0,r.jsx)(t.a,{href:"https://grpc.github.io/grpc/core/md_doc_statuscodes.html",children:"the official documentation"}),". The most common error codes you will encounter are ",(0,r.jsx)(t.code,{children:"NOT_FOUND"}),", ",(0,r.jsx)(t.code,{children:"FAILED_PRECONDITION"}),", ",(0,r.jsx)(t.code,{children:"ALREADY_EXISTS"}),", and ",(0,r.jsx)(t.code,{children:"INVALID_ARGUMENT"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["When handling errors from the LittleHorse API, you should treat the status code as a machine-readable signal, and the error-message should be treated as a ",(0,r.jsx)(t.em,{children:"human-readable"})," debugging aid. Your control flow logic should not depend on the content of the error message; it should only pay attention to the error status code."]}),"\n",(0,r.jsxs)(t.p,{children:["LittleHorse ",(0,r.jsx)(t.strong,{children:"currently"})," does not utilize the GRPC Trailers to send error content in the form of a well-formed protobuf message."]}),"\n",(0,r.jsxs)(t.p,{children:["In the example below, we will make a ",(0,r.jsx)(t.code,{children:"RunWf"})," request and provide the ",(0,r.jsx)(t.code,{children:"id"})," of the ",(0,r.jsx)(t.code,{children:"WfRun"})," which we want to run. Such a request will fail with an ",(0,r.jsx)(t.code,{children:"ALREADY_EXISTS"})," error if the ",(0,r.jsx)(t.code,{children:"WfRun"})," already exists. The example below will show you how to catch such an error."]}),"\n",(0,r.jsxs)(o.A,{children:[(0,r.jsx)(i.A,{value:"java",label:"Java",default:!0,children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'package io.littlehorse.quickstart;\n\nimport java.io.IOException;\nimport io.grpc.StatusRuntimeException;\nimport io.grpc.Status.Code;\nimport io.littlehorse.sdk.common.config.LHConfig;\nimport io.littlehorse.sdk.common.proto.LittleHorseGrpc.LittleHorseBlockingStub;\nimport io.littlehorse.sdk.common.proto.RunWfRequest;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        LHConfig config = new LHConfig();\n        LittleHorseBlockingStub client = config.getBlockingStub();\n\n        // Only one WfRun may exist with a given ID.\n        String wfRunId = "some-wf-run-id";\n\n        try {\n            // Run a WfSpec and set the WfRunId beforehand.\n            client.runWf(RunWfRequest.newBuilder()\n                    .setWfSpecName("quickstart")\n                    .setId(wfRunId)\n                    .build());\n        } catch(StatusRuntimeException exn) {\n            // All GRPC errors are in the form of `StatusRuntimeException`, which extends\n            // `RuntimeException` and contains a `io.grpc.Status` object.\n            if (exn.getStatus().getCode() == Code.ALREADY_EXISTS) {\n                System.out.println("The wfRun already exists!");\n            } else {\n                System.out.println("Yikes, we have a different error.");\n                throw exn;\n            }\n        }\n\n    }\n}\n'})})}),(0,r.jsxs)(i.A,{value:"go",label:"Go",children:[(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'package main\n\nimport (\n\t"context"\n\t"fmt"\n\t"log"\n\n\t"github.com/littlehorse-enterprises/littlehorse/sdk-go/common"\n\t"github.com/littlehorse-enterprises/littlehorse/sdk-go/common/model"\n\n\t// Use the GRPC utilities to inspect GRPC errors\n\t"google.golang.org/grpc/codes"\n\t"google.golang.org/grpc/status"\n)\n\nfunc main() {\n\t// Get a client\n\tconfig := common.NewConfigFromEnv()\n\tclient, _ := config.GetGrpcClient()\n\n\twfRunId := "my-wf-run-id"\n\treq := &model.RunWfRequest{\n\t\tId:         &wfRunId,\n\t\tWfSpecName: "quickstart",\n\t}\n\n\tresult, err := (*client).RunWf(context.Background(), req)\n\tif err != nil {\n\t\t// First, check if it is a GRPC error\n\t\tst, ok := status.FromError(err)\n\t\tif ok {\n\t\t\t// Check the status\n\t\t\tif st.Code() == codes.AlreadyExists {\n\t\t\t\tfmt.Println("The WfRun with the specified ID already exists!")\n\t\t\t} else {\n\t\t\t\tfmt.Println("Got another error from LittleHorse")\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t} else {\n\t\t\t// Handle non-GRPC errors\n\t\t\tfmt.Println("Got a non-GRPC error")\n\t\t\tlog.Fatal(err)\n\t\t}\n\t} else {\n\t\tcommon.PrintProto(result)\n\t}\n}\n'})}),(0,r.jsx)(t.admonition,{type:"note",children:(0,r.jsx)(t.p,{children:"Error handling in Go is messy due to some weird decisions made by the language authors."})})]}),(0,r.jsxs)(i.A,{value:"python",label:"Python",children:[(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'import grpc\nfrom littlehorse.config import LHConfig\nfrom littlehorse.model import RunWfRequest\n\nconfig = LHConfig()\nclient = config.stub()\nwf_run_id = "obi-wan"\n\ntry:\n    client.RunWf(RunWfRequest(\n        wf_spec_name="quickstart",\n        id=wf_run_id,\n    ))\nexcept grpc.RpcError as e:\n    if e.code() == grpc.StatusCode.ALREADY_EXISTS:\n        # then a WfRun already exists with that id.\n        print("WfRun with specified id already exists!")\n    else:\n        raise e\n'})}),(0,r.jsxs)(t.admonition,{type:"note",children:[(0,r.jsxs)(t.p,{children:["In python GRPC, the ",(0,r.jsx)(t.code,{children:".code()"})," method is an internal method of the ",(0,r.jsx)(t.code,{children:"RpcError"})," class so your code linters may complain about it. The alternative to using that method is not much better: the ",(0,r.jsx)(t.a,{href:"https://grpc.github.io/grpc/python/grpc_status.html",children:(0,r.jsx)(t.code,{children:"grpc-status"})})," package requires adding another dependency to your project and is also ",(0,r.jsx)(t.code,{children:"EXPERIMENTAL"}),"."]}),(0,r.jsxs)(t.p,{children:["Note, however, that the ",(0,r.jsx)(t.code,{children:".code()"})," method is safe to use as the ",(0,r.jsx)(t.code,{children:"littlehorse-client"})," package has tested it and pins to a version with which it works."]})]})]})]}),"\n",(0,r.jsx)(t.h2,{id:"read-only-requests-and-mutating-requests",children:"Read-Only Requests and Mutating Requests"}),"\n",(0,r.jsx)(t.p,{children:"In LittleHorse, there are two predominant types of GRPC requests:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Read-Only Requests, which simply returns information about the current state of the system without altering it (eg. get a ",(0,r.jsx)(t.code,{children:"WfRun"})," via the ",(0,r.jsx)(t.code,{children:"rpc GetWfRun"}),"), and"]}),"\n",(0,r.jsxs)(t.li,{children:["Mutating Requests, which may alter the state of the system (eg. run a ",(0,r.jsx)(t.code,{children:"WfRun"})," via the ",(0,r.jsx)(t.code,{children:"rpc RunWf"}),")."]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["In LittleHorse, all Read-Only Requests (with the exception of ",(0,r.jsx)(t.code,{children:"rpc Whoami"}),") start with ",(0,r.jsx)(t.code,{children:"Get"}),", ",(0,r.jsx)(t.code,{children:"List"}),", or ",(0,r.jsx)(t.code,{children:"Search"}),". Any other request is a Mutating Request."]}),"\n",(0,r.jsxs)(t.p,{children:["All Mutating Requests in LittleHorse ",(0,r.jsx)(t.em,{children:"can be"})," made idempotent if you pass in the proper information. For example, if you pass in the ",(0,r.jsx)(t.code,{children:"id"})," field on the ",(0,r.jsx)(t.code,{children:"rpc RunWf"}),", you can safely retry the request multiple times and only one ",(0,r.jsx)(t.code,{children:"WfRun"})," will be created."]}),"\n",(0,r.jsx)(t.h2,{id:"list-and-search",children:"List and Search"}),"\n",(0,r.jsxs)(t.p,{children:["List Requests and Search Requests are highly similar, with one distinct difference: a ",(0,r.jsx)(t.em,{children:"List Request"})," returns a series of ",(0,r.jsx)(t.em,{children:"objects"}),", whereas a Search Request returns a series of ",(0,r.jsx)(t.em,{children:"object id's"}),". For example, the ",(0,r.jsx)(t.code,{children:"rpc ListTaskRun"})," returns a ",(0,r.jsx)(t.code,{children:"TaskRunList"})," (list of ",(0,r.jsx)(t.code,{children:"TaskRun"}),"'s) whereas the ",(0,r.jsx)(t.code,{children:"rpc SearchTaskRun"})," returns a ",(0,r.jsx)(t.code,{children:"TaskRunIdList"})," (list of ",(0,r.jsx)(t.code,{children:"TaskRunId"}),"'s)."]}),"\n",(0,r.jsxs)(t.p,{children:["Generally, List Requests list all objects of a certain type belonging to a specific ",(0,r.jsx)(t.code,{children:"WfRun"}),", but that is an observation and not a rule."]}),"\n",(0,r.jsx)(t.h3,{id:"what-is-an-lh-api-object",children:"What is an LH API Object?"}),"\n",(0,r.jsxs)(t.p,{children:["Something that is stored in the LittleHorse Data Store and can be retrieved through some request ",(0,r.jsx)(t.code,{children:"rpc GetFoo"}),' in the LittleHorse API is refered to as a "LittleHorse API Object". Some common types of LH Api Objects are ',(0,r.jsx)(t.code,{children:"WfRun"}),", ",(0,r.jsx)(t.code,{children:"WfSpec"}),", ",(0,r.jsx)(t.code,{children:"TaskRun"}),", and ",(0,r.jsx)(t.code,{children:"TaskDef"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:['An "Object Id" is a unique identifier for an LH API Object and contains all of the necessary information required to retrieve the LH API Object from the API via a request ',(0,r.jsx)(t.code,{children:"rpc GetFoo"}),", such as: ",(0,r.jsx)(t.code,{children:"rpc GetWfRun"}),", ",(0,r.jsx)(t.code,{children:"rpc GetWfSpec"}),", ",(0,r.jsx)(t.code,{children:"rpc GetTaskRun"}),", and ",(0,r.jsx)(t.code,{children:"rpc GetTaskDef"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["For a given LH API Object Type (in this example, ",(0,r.jsx)(t.code,{children:"TaskRun"}),"), it is common to have some or all of the following requests:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-protobuf",children:"message TaskRunId {\n    WfRunId wf_run_id = 1;\n    string guid = 2;\n}\n\nmessage TaskRunIdList {\n    repeated TaskRunId results = 1;\n    optional bytes bookmark = 2; // for cursor-based pagination\n}\n\nmessage TaskRunList {\n    repeated TaskRun results = 1;\n    optional bytes bookmark = 2; // for cursor-based pagination\n}\n\n// ...\nservice LittleHorse {\n    // ...\n    rpc GetTaskRun(TaskRunId) returns(TaskRun) {}\n    rpc ListTaskRun(ListTaskRunRequest) returns (TaskRunList) {}\n    rpc SearchTaskRun(SearchTaskRunRequest) returns (TaskRunIdList) {}\n}\n"})}),"\n",(0,r.jsx)(t.h3,{id:"pagination",children:"Pagination"}),"\n",(0,r.jsxs)(t.p,{children:["Both List Requests and Search Requests alike use ",(0,r.jsx)(t.a,{href:"https://slack.engineering/evolving-api-pagination-at-slack/",children:"Cursor-Based Pagination"}),". For an example, we will look at the ",(0,r.jsx)(t.code,{children:"rpc SearchTaskRun"}),". Note the ",(0,r.jsx)(t.code,{children:"optional bytes bookmark"})," field and the ",(0,r.jsx)(t.code,{children:"optional int32 limit"})," field."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-protobuf",children:"// Searches for TaskRuns by various criteria.\nmessage SearchTaskRunRequest {\n    optional bytes bookmark = 1;\n    optional int32 limit = 2;\n    string task_def_name = 3;\n    optional TaskStatus status = 4;\n    optional google.protobuf.Timestamp earliest_start = 5;\n    optional google.protobuf.Timestamp latest_start = 6;\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"limit"})," field determines the maximum number of results to be returned in a single request."]}),"\n",(0,r.jsxs)(t.p,{children:["Recall the ",(0,r.jsx)(t.code,{children:"optional bytes bookmark"})," field in the ",(0,r.jsx)(t.code,{children:"TaskRunIdList"})," proto. The ",(0,r.jsx)(t.code,{children:"TaskRunIdList"})," is the response format for the request ",(0,r.jsx)(t.code,{children:"rpc SearchTaskRun"}),". If the ",(0,r.jsx)(t.code,{children:"rpc SearchTaskRun"})," has more results than can be returned in one request (see ",(0,r.jsx)(t.code,{children:"limit"}),"), then the ",(0,r.jsx)(t.code,{children:"bookmark"})," field of the ",(0,r.jsx)(t.code,{children:"TaskRunIdList"})," message is set to a byte-string that serves as a ",(0,r.jsx)(t.em,{children:"cursor"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["To retrieve the next page of results, simply pass in the ",(0,r.jsx)(t.code,{children:"bookmark"})," from your previous request to your next request."]}),"\n",(0,r.jsxs)(t.p,{children:["The below example shows how to iterate through a paginated list of ",(0,r.jsx)(t.code,{children:"TaskRun"}),"s."]}),"\n",(0,r.jsxs)(o.A,{children:[(0,r.jsx)(i.A,{value:"java",label:"Java",default:!0,children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-java",children:'package io.littlehorse.quickstart;\n\nimport java.io.IOException;\nimport io.littlehorse.sdk.common.LHLibUtil;\nimport io.littlehorse.sdk.common.config.LHConfig;\nimport io.littlehorse.sdk.common.proto.LittleHorseGrpc.LittleHorseBlockingStub;\nimport io.littlehorse.sdk.common.proto.SearchTaskRunRequest;\nimport io.littlehorse.sdk.common.proto.TaskRunId;\nimport io.littlehorse.sdk.common.proto.TaskRunIdList;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n        LHConfig config = new LHConfig();\n        LittleHorseBlockingStub client = config.getBlockingStub();\n\n        TaskRunIdList results = client.searchTaskRun(SearchTaskRunRequest.newBuilder()\n                .setTaskDefName("greet")\n                .setLimit(5)\n                .build());\n        processTaskRuns(results);\n\n        while (results.hasBookmark()) {\n            results = client.searchTaskRun(SearchTaskRunRequest.newBuilder()\n                    .setTaskDefName("greet")\n                    .setLimit(5)\n                    .setBookmark(results.getBookmark())\n                    .build());\n\n            processTaskRuns(results);\n        }\n    }\n\n    private static void processTaskRuns(TaskRunIdList taskRuns) {\n        System.out.println("Processing a batch of size: " + taskRuns.getResultsCount());\n        for (TaskRunId taskRun : taskRuns.getResultsList()) {\n            System.out.println(LHLibUtil.protoToJson(taskRun));\n        }\n    }\n}\n'})})}),(0,r.jsx)(i.A,{value:"go",label:"Go",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-go",children:'package main\n\nimport (\n\t"context"\n\t"fmt"\n\t"strconv"\n\n\t"github.com/littlehorse-enterprises/littlehorse/sdk-go/common"\n\t"github.com/littlehorse-enterprises/littlehorse/sdk-go/common/model"\n\t// Use the GRPC utilities to inspect GRPC errors\n)\n\nfunc main() {\n\t// Get a client\n\tconfig := common.NewConfigFromEnv()\n\tclient, _ := config.GetGrpcClient()\n\n\tlimit := int32(5)\n\treq := model.SearchTaskRunRequest{\n\t\tTaskDefName: "greet",\n\t\tLimit:       &limit,\n\t}\n\tresults, _ := (*client).SearchTaskRun(context.Background(), &req)\n\n\tprocessTaskRuns(results)\n\n\t// For some reason GoLang decided to use `for` instead of `while`...\n\tfor results.Bookmark != nil {\n\t\treq.Bookmark = results.Bookmark\n\t\tresults, _ = (*client).SearchTaskRun(context.Background(), &req)\n\t\tprocessTaskRuns(results)\n\t}\n}\n\nfunc processTaskRuns(taskRuns *model.TaskRunIdList) {\n\tfmt.Println("Processing a batch of size " + strconv.Itoa(len(taskRuns.Results)))\n\n\tfor _, taskRunId := range taskRuns.Results {\n\t\tcommon.PrintProto(taskRunId)\n\t}\n}\n\n'})})}),(0,r.jsx)(i.A,{value:"python",label:"Python",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'from littlehorse.config import LHConfig\nfrom littlehorse.model import *\nfrom google.protobuf.json_format import MessageToJson\n\n\ndef process_task_runs(task_run_ids: TaskRunIdList):\n    print("Processing a batch of size " + str(len(task_run_ids.results)))\n    for task_run_id in task_run_ids.results:\n        print(MessageToJson(task_run_id))\n\n\nif __name__ == \'__main__\':\n    config = LHConfig()\n    client = config.stub()\n\n    results: TaskRunIdList = client.SearchTaskRun(SearchTaskRunRequest(\n        task_def_name="greet",\n        limit=5,\n    ))\n\n    process_task_runs(results)\n\n    # the `HasField()` method is the proper way to check for presence of an\n    # `optional` field in python Protobuf.\n    while results.HasField("bookmark"):\n        new_request = SearchTaskRunRequest(\n            task_def_name="greet",\n            limit=5,\n            # pass in the bookmark from the previous call\n            bookmark=results.bookmark,\n        )\n        results = client.SearchTaskRun(new_request)\n        process_task_runs(results)\n\n'})})})]})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},9365:(e,t,n)=>{n.d(t,{A:()=>i});n(6540);var r=n(8215);const s={tabItem:"tabItem_Ymn6"};var o=n(4848);function i(e){let{children:t,hidden:n,className:i}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,r.A)(s.tabItem,i),hidden:n,children:t})}},1470:(e,t,n)=>{n.d(t,{A:()=>v});var r=n(6540),s=n(8215),o=n(3104),i=n(6347),a=n(205),l=n(7485),c=n(1682),u=n(9466);function d(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??function(e){return d(e).map((e=>{let{props:{value:t,label:n,attributes:r,default:s}}=e;return{value:t,label:n,attributes:r,default:s}}))}(n);return function(e){const t=(0,c.X)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function p(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:n}=e;const s=(0,i.W6)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l.aZ)(o),(0,r.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(s.location.search);t.set(o,e),s.replace({...s.location,search:t.toString()})}),[o,s])]}function f(e){const{defaultValue:t,queryString:n=!1,groupId:s}=e,o=h(e),[i,l]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:o}))),[c,d]=m({queryString:n,groupId:s}),[f,g]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[s,o]=(0,u.Dv)(n);return[s,(0,r.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:s}),x=(()=>{const e=c??f;return p({value:e,tabValues:o})?e:null})();(0,a.A)((()=>{x&&l(x)}),[x]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);l(e),d(e),g(e)}),[d,g,o]),tabValues:o}}var g=n(2303);const x={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var k=n(4848);function b(e){let{className:t,block:n,selectedValue:r,selectValue:i,tabValues:a}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.a_)(),u=e=>{const t=e.currentTarget,n=l.indexOf(t),s=a[n].value;s!==r&&(c(t),i(s))},d=e=>{let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const n=l.indexOf(e.currentTarget)+1;t=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(e.currentTarget)-1;t=l[n]??l[l.length-1];break}}t?.focus()};return(0,k.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.A)("tabs",{"tabs--block":n},t),children:a.map((e=>{let{value:t,label:n,attributes:o}=e;return(0,k.jsx)("li",{role:"tab",tabIndex:r===t?0:-1,"aria-selected":r===t,ref:e=>l.push(e),onKeyDown:d,onClick:u,...o,className:(0,s.A)("tabs__item",x.tabItem,o?.className,{"tabs__item--active":r===t}),children:n??t},t)}))})}function j(e){let{lazy:t,children:n,selectedValue:s}=e;const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===s));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return(0,k.jsx)("div",{className:"margin-top--md",children:o.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==s})))})}function R(e){const t=f(e);return(0,k.jsxs)("div",{className:(0,s.A)("tabs-container",x.tabList),children:[(0,k.jsx)(b,{...t,...e}),(0,k.jsx)(j,{...t,...e})]})}function v(e){const t=(0,g.A)();return(0,k.jsx)(R,{...e,children:d(e.children)},String(t))}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var r=n(6540);const s={},o=r.createContext(s);function i(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);